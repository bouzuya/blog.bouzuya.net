# goal

- [ ] 『計算機プログラムの構造と解釈 (SICP) 』を読む (2章)
- [x] [bouzuya/beater][] の browser support をつくる (0.4.0)

# diary

- 2016-06-19 Sun 朝X。英語X。読書X。generator function を試す。旅行の準備。
- 2016-06-18 Sat 朝X。英語X。読書X。
- 2016-06-17 Fri 朝O。英語X。読書X。TimeKeeper.js 公開 (beater 0.4.0 の検証)。
- 2016-06-16 Thu 朝X。英語X。読書X。beater 0.4.0 公開。
- 2016-06-15 Wed 朝X。英語X。読書X。beater-reporter & beater-cli-reporter 公開。
- 2016-06-14 Tue 朝X。英語X。読書X。moment の wrapper 。beater-cli@0.1.0 公開。
- 2016-06-13 Mon 朝X。英語X。読書X。browser support の実装を進めている。一転 API を維持する案で。

# blog

- 2016-06-19 Sun 今週のふりかえり
- 2016-06-18 Sat プロなら道具は選びモトをとれ
- 2016-06-17 Fri TimeKeeper.js をつくった
- 2016-06-16 Thu beater 0.4.0 をつくった
- 2016-06-15 Wed beater-cli-reporter をつくった
- 2016-06-14 Tue beater-cli をつくった
- 2016-06-13 Mon beater の設計


## 2016-06-18 Sat

感銘を受けた。

<blockquote class="twitter-tweet" data-lang="ja"><p lang="ja" dir="ltr">名言多すぎ。 <a href="https://t.co/2yHfFuLBh2">pic.twitter.com/2yHfFuLBh2</a></p>&mdash; 汎猫 (@hanneko3) <a href="https://twitter.com/hanneko3/status/742683727554170881">2016年6月14日</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

台詞を抜粋する。

> 年に数回しか
> 使わない人間なら
> ぜいたくだけどね
>
> プロなら
> それは必需品だ
>
> ピアニストが四畳半一間に
> グランド・ピアノを
> ぶち込んでその上に
> 布団敷いて寝てたって
> そりゃぜいたくとは言わん
>
> なぜなら　ピアノは
> 彼の生活をささえる
> 一部だからだ
>
> カメラマンにとっての
> カメラも同じだ
>
> どんな高級機を
> 選んだって　それで
> 生活するんだから
> ぜーたくとは言わない
>
> そのかわり
> プロなら
> それでモトを
> 取りかえせ！！
>
> それができなきゃ
> いつまでたっても
> ぜーたくアマチュアからぬけきれん
>
> 弘法筆を
> 選ばずなんて
> 言うけどね
> 趣味ならともかく
> 商売なら筆は
> 選ばないとな

(ピアニスト|カメラマン)が高い(ピアノ|カメラ)を買っても、生活をささえる一部なので、ぜいたくではない。モトをとれるなら、ぜいたくではない。生活をささえる道具は選ぶべきだ。

ぼくの解釈で一言にすればこうだ。

「プロなら道具は選びモトをとれ」

ぼくはプログラマ・エンジニアだ。道具は自分自身・プログラミング言語・ライブラリ・フレームワークといった知識・経験・能力だ。これをお金ではなく時間で得る。かけた時間をより大きい価値として回収できる (モトをとれる) か。

インプットばかりではなくアウトプットも考える姿勢は、以前からとってきたつもりだった。「モトをとる」という意識が足りていなかったかもしれない。

ちなみにこの漫画を Kindle で買って読んでみたが、予想通り興味の外って感じだった。[新谷かおる マグナムロマンシリーズ　4　シリーズ1/1000sec.](https://www.amazon.co.jp/dp/B00JB3F9DU)

## 2016-06-17 Fri

TimeKeeper.js ([bouzuya/time-keeper-js][]) をつくった。

TimeKeeper.js は simple な date-time library 。

次の特徴を持つ。

- simple な api
  - milliseconds に対応しない
  - day of week に対応しない
  - ISO8601 の標準の形式 (`2006-01-02T15:04:05-07:00`) 以外の formatter に対応しない
  - invalid な状態 (NullObject) に対応しない
  - mutable な状態に対応しない
- TypeScript (`.d.ts`) に対応する

極力 simple な api にしている。README の Example ですべての api だ。

```ts
import * as assert from 'assert';
import { now, parseISOString, parseUNIXTime } from 'time-keeper';

const dt1 = now();
const dt2 = parseUNIXTime(dt1.toUNIXTime());
assert(dt1.toString() === dt2.toString());

const dt3 = parseISOString('2016-06-17T23:28:40+09:00');
assert(dt3.get('year') === 2016);
assert(dt3.get('month') === 6);
assert(dt3.get('date') === 17);
assert(dt3.get('hour') === 23);
assert(dt3.get('minute') === 28);
assert(dt3.get('second') === 40);
assert(dt3.toTimeZoneOffsetString() === '+09:00');

const dt4 = dt3.inTimeZone('+00:00');
assert(dt3.toISOString() === '2016-06-17T23:28:40+09:00');
assert(dt4.toISOString() === '2016-06-17T14:28:40+00:00');

const dt5 = dt4.plus(2, 'day');
assert(dt4.toISOString() === '2016-06-17T14:28:40+00:00');
assert(dt5.toISOString() === '2016-06-19T14:28:40+09:00');
```

TimeKeeper.js の目的としては次の 2 つだ。

- [momentjs/moment][] の誤用の防止
- [bouzuya/beater][] 0.4.0 の検証

JavaScript 界隈では定番の date-time library である `moment` 。`moment` はとても良く出来た library だ。しかし `moment` はいくつかの罠があり、ぼくのまわりでそれに起因する事故が起きている。例を挙げると、 mutable であること・通常の parse だと time-zone が local になる・invalid な状態を許容する・`format()` の指定の誤りなどだ。そこで機能を制限し、自分の想像の範囲で安全に動作する library をつくろうと考えた。

[2016-06-16][] に書いた beater 0.4.0 の検証を兼ねたかった。適度に小さい library が欲しかった。

TimeKeeper.js の実装は最近のぼくの標準である Node.js + TypeScript (+typings) を使っている。`moment` を wrap しただけのお手軽実装だ。先の目的どおりに test は beater (+ beater-cli) + power-assert 。手堅く慣れた tool を使いつつ、beater の検証を図った感じ。

あとは特徴として TypeScript の String Literal Types を使っている点を挙げたい。上記の Example には文字列で `field` や `unit` を取る点がある。このあたりは `moment` の `format()` 指定のように誤爆すると思われるかもしれないが、実は TypeScript user なら型安全だ。 [TypeScript の String Literal Types ](https://www.typescriptlang.org/docs/handbook/advanced-types.html#string-literal-types) なので間違えることなく使える。

ほかには、実装の隠蔽および TypeScript の private constructor をつくれない制約を回避するために、 `interface` とそれを返す関数を `export` している。Java 界隈なら当たり前のように見かけるのだけど TypeScript ではどうなんだろう……。

beater 0.4.0 の使い勝手は上々。API は変更されているものの 0.3.0 とほとんど差を感じなかった。browser のほうは試せていないし、怪しいけれど……。

TimeKeeper.js については実用の中で洗練していきたい。

## 2016-06-16 Thu

[bouzuya/beater][] 0.4.0 をつくった

[bouzuya/beater][] は alt [mochajs/mocha][] を意識した simple な test framework 。[yosuke-furukawa/eater][] に影響されてつくりはじめた。

0.4.0 の変更は browser support で、利用者側に影響のある変更を含んでいる。

- beater の api の変更
- CLI 部分の [bouzuya/beater-cli][] への抽出
- beater-reporter を interface のみに変更
- [bouzuya/beater-cli-reporter][] の追加 (標準 reporter を beater-reporter から移動)
- [bouzuya/beater-html-reporter][] の追加

API の変更など詳細は [bouzuya/beater][] の README を参照してほしい。

まず browser support とは何か。ぼくの中では browser で beater (test) を動かし、結果を表示できることが browser support だ。browser で beater を動かすために browserify / webpack などにより `require()` の変換が必要なことは許容する。また、これは beater が browser を動かして test を動かすことではない。あくまでも browser の上で beater が test を動かすことだ。

では、なぜ browser support が必要なのか。それは beater が "post mocha" を目指す ([2016-06-08][]) からだ。いまの気持ちとしては "alt mocha" 。mocha の代替の選択肢を目指したい。browser support は "alt mocha" のほかに Kyoto.js team での意見を受けた ([2016-06-09][]) こともある。

browser support の過程ではいくつかのことを学んだ。 Node.js の標準 library や、それに依存する npm package 、動的な `require()` ([2016-06-10][]) は browser では思った通りには動かせないことなどだ。

これは eater の前提である file 単位での test という仕様の維持が難しいことを意味する。 file 単位での test を避けるために test を ES Module 化する案 ([2016-06-13][]) を挙げた。この案は使い勝手の面で数人から否定されたため、却下した (将来的にはこちらの案でもつくってみたい) 。

また Node.js への依存を切り離す必要性から [bouzuya/beater-cli][] や [bouzuya/beater-cli-reporter][] などの npm package を明確に切り離した。

今後の課題は次のとおりだ。

- 具体例の拡充
- document の整備
- beater の Error Handling の強化
- Reporter 向けの Error 情報の強化
- [bouzuya/beater-html-reporter][] の強化
- 他の assertion / test-double / coverage / reporter との連携

関連記事:

- [2016-06-08][] beater の紹介
- [2016-06-09][] 0.4.0 browser support 検討 (1)
- [2016-06-10][] 0.4.0 browser support 検討 (2)
- [2016-06-13][] 0.4.0 api 検討
- [2016-06-14][] beater-cli の紹介
- [2016-06-15][] beater-cli-reporter / beater-reporter の紹介

## 2016-06-15 Wed

[bouzuya/beater-cli-reporter][] をつくった。

[bouzuya/beater-cli-reporter][] は [bouzuya/beater][] の reporter だ。 [bouzuya/beater-cli][] を使用した際の default reporter でもある。

beater-cli-reporter をつくった理由は beater-cli と同じだ。beater の browser support のためだ。 Node.js への依存を切り離すためだ。 beater-cli により child_process への依存を切り離したのと同様に、beater-cli-reporter でも colo への依存を切り離した。

実装もまた beater-cli と同様に copy & paste だ。Node.js & TypeScript を使っており、[bouzuya/beater-reporter][] から copy & paste した。beater-reporter は役割を beater-cli-reporter に譲り、beater の reporter を作成するための interface を提供することにした。つまり beater-reporter は interface を、beater-cli-reporter は beater-cli の reporter の実装を提供する。

beater いろいろなものを切り離して身軽になってきた。browser support とは関係なく、これは良いことだ。

## 2016-06-14 Tue

[bouzuya/beater-cli][] をつくった。まだ使えない。

[bouzuya/beater-cli][] は [bouzuya/beater][] のための CLI 。beater は次の 0.4.0 から browser support のために Node.js の標準 package への依存を減らす。切り離された Node.js 依存の部分が beater-cli だ。beater-cli により beater 0.3.0 と同様の使い勝手を維持する。

実装は基本的には beater からの copy & paste 。Node.js & TypeScript で書かれており、minimist で option を parse する。test は beater でする予定だが、現状は dummy を置いているだけだ。

0.4.0 での挙動としては beater を使って書かれた test script を `child_process.fork()` して、各ファイルから `process.send()` された結果を受け取って表示する。

beater から beater-cli を独立させたことで、browser から扱いやすくなったはずだ……そう信じたい。

## 2016-06-13 Mon

[bouzuya/beater][] の設計を検討したことを書く。

beater の browser support を進めている。[2016-06-10][] に書いたとおり、想定どおりに動かなかったため迷走している。

最終的な 2 案は [bouzuya/beater#3](https://github.com/bouzuya/beater/issues/3) にある。それぞれがまったく異なる設計になっている。

案 1 は `Test` を export する ES Modules を使うものだ。この案の良い点は `test()` が副作用を持たないことだ。あくまでも `test()` は `Test` を返す関数であって、その実行はしない。`Test` を `run(tests);` のように実行する。`reporter` を指定するなら `run(tests, reporter);` だろうか。

```js
import { test } from 'beater';
const t = test('foo 1', () => {
  assert(1 === 1);
});
export default t;
```

案 2 は `test()` で `Test` を実行する。同一 instance でないと `reporter` をまとめられないため、 `const { test } = beater();` は `./test/helper.ts` などの 1 file にする必要がある。`reporter` を指定するなら `const { test } = beater(reporter);` だろう。

```js
import beater from 'beater';
const { test } = bearter();
test('foo 1', () => {
  assert(1 === 1);
});
```

案 1 は `export default t;` などの記述を嫌がる声があったのだけど、個人的には案 1 のほうが最終的に扱いやすくなるとは思う。しかし、今回は案 2 で進めようと思う。こちらのほうがよりありふれた test framework に近いからだ。だからこそ案 1 を選びたい気持ちはあるのだけど、まずは post mocha として使ってもらえる test framework を目指したい。
